" autoload/laravel/artisan.vim - Laravel Artisan support for Vim
" Maintainer: Noah Frederick

""
" Change working directory to {dir}, respecting current window's local dir
" state. Returns old working directory to be restored later by a second
" invocation of the function.
function! s:cd(dir) abort
  let cd = exists('*haslocaldir') && haslocaldir() ? 'lcd' : 'cd'
  let cwd = getcwd()
  execute cd fnameescape(a:dir)
  return cwd
endfunction

""
" Implement the one-argument version of uniq() for older Vims.
function! s:uniq(list) abort
  if exists('*uniq')
    return uniq(a:list)
  endif

  let i = 0
  let last = ''

  while i < len(a:list)
    let str = string(a:list[i])
    if str ==# last && i > 0
      call remove(a:list, i)
    else
      let last = str
      let i += 1
    endif
  endwhile

  return a:list
endfunction

""
" Get output from Artisan with {args} in project's root directory.
function! laravel#artisan#capture(args) abort
  try
    let cwd = s:cd(laravel#app().path())
    let result = systemlist(laravel#app().makeprg(a:args))
  finally
    call s:cd(cwd)
  endtry

  return result
endfunction

""
" Get Dict of artisan subcommands.
function! s:artisan_commands() abort
  if laravel#app().cache.needs('artisan_commands')
    let lines = laravel#artisan#capture(['list', '--raw'])

    if v:shell_error != 0
      return []
    endif

    call map(lines, "matchstr(v:val, '^.\\{-}\\ze\\s')")
    call filter(lines, 'v:val != ""')

    call laravel#app().cache.set('artisan_commands', lines)
  endif

  return laravel#app().cache.get('artisan_commands')
endfunction

""
" The :Artisan command.
function! laravel#artisan#exec(...) abort
  let args = copy(a:000)
  let bang = remove(args, 0)

  " if exists(':terminal')
  "   tabedit %
  "   execute 'lcd' fnameescape(laravel#app().path())
  "   execute 'terminal' laravel#app().makeprg(args)
  " else
  let cwd = s:cd(laravel#app().path())
  execute '!' . laravel#app().makeprg(args)
  call s:cd(cwd)
  " endif

  call s:artisan_doautocmd(args, bang, v:shell_error)
  return ''
endfunction

""
" Execute Artisan autocommand with event object.
function! s:artisan_doautocmd(args, bang, status) abort
  let g:artisan = {
        \   'args': a:args,
        \   'bang': a:bang,
        \   'status': a:status,
        \ }
  let g:artisan.flags = filter(copy(a:args), 'v:val =~# "^-"')
  let g:artisan.rest = filter(copy(a:args), 'v:val !~# "^-"')
  if empty(g:artisan.rest)
    let parts = ['']
  else
    let parts = split(remove(g:artisan.rest, 0), ':')
  endif
  let g:artisan.namespace = len(parts) > 1 ? parts[0] : ''
  let g:artisan.name = len(parts) > 1 ? parts[1] : parts[0]

  silent doautocmd User Artisan
endfunction

augroup laravel_artisan
  autocmd!
  if exists('g:loaded_projectionist')
    autocmd User Artisan nested
          \ if g:artisan.status == 0 && g:artisan.namespace ==# 'make' |
          \   execute s:artisan_edit(g:artisan) |
          \ endif
  endif
augroup END

""
" Edit the file generated by an Artisan command.
function! s:artisan_edit(command) abort
  if a:command.namespace !=# 'make'
    return ''
  endif

  if a:command.name ==# 'auth'
    return ''
  elseif a:command.name ==# 'console'
    let type = 'command'
  elseif a:command.name ==# 'model'
    let type = 'lib'
  else
    let type = a:command.name
  endif

  let classname = remove(a:command.rest, 0)
  let namespace = ''

  if a:command.name ==# 'migration'
    let classname = laravel#app().expand_migration(classname)
  elseif a:command.name ==# 'test' && laravel#app().has('namespaced-tests')
    let namespace = index(a:command.args, '--unit') != -1 ? 'Unit/' : 'Feature/'
  endif

  return 'E' . type . a:command.bang . ' ' . namespace . classname
endfunction

""
" @private
" Completion for the :Artisan command.
function! laravel#artisan#complete(A, L, P) abort
  let commands = copy(s:artisan_commands())

  silent! call remove(commands, index(commands, 'help'))
  let subcommand = matchstr(a:L, '\<\(' . join(commands, '\|') . '\)\>')

  let candidates = s:artisan_flags['_global']

  if empty(subcommand)
    let candidates = candidates + commands + ['help']
  elseif has_key(s:artisan_flags, subcommand)
    let candidates = candidates + s:artisan_flags[subcommand]
  endif

  return s:filter_completions(candidates, a:A)
endfunction

""
" Sort and filter completion {candidates} based on the current argument {A}.
" Adapted from bundler.vim.
function! s:filter_completions(candidates, A) abort
  let candidates = copy(a:candidates)
  if len(candidates) == 0
    return []
  endif
  call sort(candidates)
  call s:uniq(candidates)

  let commands = filter(copy(candidates), "v:val[0] !=# '-'")
  let flags = filter(copy(candidates), "v:val[0] ==# '-'")

  let candidates = commands + flags

  let filtered = filter(copy(candidates), 'v:val[0:strlen(a:A)-1] ==# a:A')
  if !empty(filtered) | return filtered | endif

  let regex = substitute(a:A, '[^/:]', '[&].*', 'g')
  let filtered = filter(copy(candidates), 'v:val =~# "^".regex')
  if !empty(filtered) | return filtered | endif

  let filtered = filter(copy(candidates), '"/".v:val =~# "[/:]".regex')
  if !empty(filtered) | return filtered | endif

  let regex = substitute(a:A, '.', '[&].*', 'g')
  let filtered = filter(copy(candidates),'"/".v:val =~# regex')
  return filtered
endfunction

" Unlike subcommands, artisan does not list switches/flags in a friendly
" format, so we hard-code them.
let s:artisan_flags = {
      \   '_global': [
      \     '--help',
      \     '-h',
      \     '--quiet',
      \     '-q',
      \     '--verbose',
      \     '-v',
      \     '-vv',
      \     '-vvv',
      \     '--version',
      \     '-V',
      \     '--ansi',
      \     '--no-ansi',
      \     '--no-interaction',
      \     '-n',
      \     '--env=',
      \   ],
      \   'db:seed': [
      \     '--class=',
      \     '--database=',
      \     '--force',
      \   ],
      \   'down': [
      \     '--message=',
      \     '--retry=',
      \   ],
      \   'help': [
      \     '--format=',
      \     '--raw',
      \   ],
      \   'key:generate': [
      \     '--show',
      \   ],
      \   'list': [
      \     '--format=',
      \     '--raw',
      \   ],
      \   'make:auth': [
      \     '--views',
      \   ],
      \   'make:console': [
      \     '--command=',
      \   ],
      \   'make:controller': [
      \     '--model=',
      \     '-m',
      \     '--resource',
      \     '-r',
      \   ],
      \   'make:job': [
      \     '--sync',
      \   ],
      \   'make:listener': [
      \     '--event=',
      \     '-e',
      \     '--queued',
      \   ],
      \   'make:mail': [
      \     '--markdown=',
      \     '-m',
      \   ],
      \   'make:migration': [
      \     '--create=',
      \     '--table=',
      \     '--path=',
      \   ],
      \   'make:model': [
      \     '--migration',
      \     '-m',
      \     '--controller',
      \     '-c',
      \     '--resource',
      \     '-r',
      \   ],
      \   'make:policy': [
      \     '--model=',
      \     '-m',
      \   ],
      \   'make:test': [
      \     '--unit'
      \   ],
      \   'migrate': [
      \     '--database=',
      \     '--force',
      \     '--path=',
      \     '--pretend',
      \     '--seed',
      \     '--step',
      \   ],
      \   'migrate:install': [
      \     '--database=',
      \   ],
      \   'migrate:refresh': [
      \     '--database=',
      \     '--force',
      \     '--path=',
      \     '--seed',
      \     '--seeder=',
      \   ],
      \   'migrate:reset': [
      \     '--database=',
      \     '--force',
      \     '--pretend',
      \   ],
      \   'migrate:rollback': [
      \     '--database=',
      \     '--force',
      \     '--pretend',
      \   ],
      \   'migrate:status': [
      \     '--database=',
      \     '--path=',
      \   ],
      \   'optimize': [
      \     '--force',
      \     '--psr',
      \   ],
      \   'queue:listen': [
      \     '--queue=',
      \     '--delay=',
      \     '--memory=',
      \     '--timeout=',
      \     '--sleep=',
      \     '--tries=',
      \   ],
      \   'queue:work': [
      \     '--queue=',
      \     '--daemon',
      \     '--delay=',
      \     '--force',
      \     '--memory=',
      \     '--sleep=',
      \     '--tries=',
      \   ],
      \   'route:list': [
      \     '--method=',
      \     '--name=',
      \     '--path=',
      \     '--reverse',
      \     '-r',
      \     '--sort=',
      \   ],
      \   'serve': [
      \     '--host=',
      \     '--port=',
      \   ],
      \   'tinker': [
      \     '--include=',
      \   ],
      \   'vendor:publish': [
      \     '--force',
      \     '--provider=',
      \     '--tag=',
      \   ],
      \ }

""
" @private
" Hack for testing script-local functions.
function! laravel#artisan#sid()
  nnoremap <SID> <SID>
  return maparg('<SID>', 'n')
endfunction

" vim: fdm=marker:sw=2:sts=2:et
